float counter = 2;
int rotatecounter = 15;
color gridForeground = color(55, 140, 40);
color gridBackground = color(0, 0, 0);
int rund = 0;
float invert = 50; 
//float rotatetrigger3 = 5;


void setupGridScene() {
}

void drawGridScene() {

  counter=counter+0.01;

  if (counter > 7.5) {
    counter = 5;

    color tmp = gridForeground;
    gridForeground = gridBackground;
    gridBackground = tmp;
    rotatecounter =rotatecounter+5;
    rund = rund+5;
    
    //rotatetrigger3 = random(0.05, 0.1);
    

    if (rund >= 40) {
      rund=0;
    }
  }


  float r = map(noise(0, frameCount*0.001), 0, 1, -width/8, width/2);
  float g = map(noise(100, frameCount*0.001), 0, 1, -width/8, width/2);
  float b = map(noise(200, frameCount*0.001), 0, 1, -width/8, width/2);
  float trcl = map(noise(200, frameCount*0.001), 0, 1, 0, width/4);
  
  //rotateX(radians(frameCount*rotatetrigger3));
  //rotateY(radians(frameCount*rotatetrigger3));
  //rotateY(radians(frameCount*rotatetrigger3);
  
//println(rotatetrigger3);

  colorMode(RGB, 255, 255, 255);

  background(gridBackground);

  int cellCountY = (int) pow(2, counter);
  float cellSize = (float) height / cellCountY;
  int cellCountX = (int) (width / cellSize);


  //translate(width/2, height/2);

  for (int x = -cellCountX / 2; x<= cellCountX /2; x++) {
    for (int y = -cellCountY / 2; y<= cellCountY /2; y++) {
      if ((x +y) % 45 ==0) {
        noStroke();

        fill(r, g, b, trcl);
        rect(x * cellSize/2, y * cellSize/4, x/2 * cellSize/2, y/2 * cellSize/6, rund);
        rotate(rotatecounter);
      }
    }
  }
}
